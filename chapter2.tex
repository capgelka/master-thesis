\chapter{Методы определения входных данных влияющих на условные переходы}

% В данной главе предлагаются два метода, основанный на символьном вы

% Для решение поставленной задачи необходимо:

% \begin{itemize}
%     \item Для каждого байта
%     \item 
% \end{itemize}

% https://www.usenix.org/system/files/conference/usenixsecurity13/sec13-paper_haller.pdf

% https://minemu.org/

% https://sites.cs.ucsb.edu/~vigna/publications/2016_SP_angrSoK.pdf

% https://www.cs.vu.nl/~herbertb/papers/borg_codaspy15.pdf

% Для начала расмотрим самый простой способ

\section{Использование символьного выполнения}

Первое что необходимо сделать, это установить соответствие между символьными переменными и байтами входного файла. Эта задача может быть решена двумя разными способами, в зависимости от используемых технологий.

\begin{itemize}
    \item В случае если используемый фреймворк предоставляет абстракцию вида ``Символьный файл'', можно просто ей воспользоваться. Символьный файл уже содержит в себе символьный массив байт, соответствующий байтам исходного файла.
    \item В противном случае необходимо использовать механизм перехвата системных вызовов. Для начала следует отслеживать вызовы \texttt{open} и \texttt{openat}, в случае если их аргумент соответствует имени отслеживаемого файла полученный дескриптор и его текущее смещение заносится в множество отслеживаемых дескрипторов. При вызове \texttt{lseek} для соответствующего дескриптора изменяется смещение, а при вызове \texttt{close} -- дескриптор удаляется из множества. Для вызовов \texttt{read} и \texttt{pread64} создаются символьные переменные, в хэш-таблицу помещается информация о соответствии байт файла. Аналогичным образом обрабатывается и работа с \texttt{mmap}.
\end{itemize}


Метод на основе динамического символьного выполнения основывается на использовании предиката пути.
Его конструирование основывается на трансляции инструкций ассемблера или промежуточного языка в формулы для SMT решателя, и выполняется существующими инструментами автоматически.
При обработке инструкции условного перехода извлекается формула соответствующая конъюнкции формул для соответствующих флагов, определяющих условный переход, после чего производится её конъюнкция с существующим предикатом пути.

Важно отметить, что предикат пути представим в виде абстрактно-синтаксического дерева. Это обусловлено тем, что уравнения для SMT-решателей в формате SMT-Lib2 представляют собой S-выражения. При этом в листьях дерева могут находиться или константы, или символьные переменные. Отсюда вытекает следующий алгоритм.
\bigskip

\begin{algorithm}[H]
\SetAlgoLined
\KwIn{Предикат пути, представленный в виде AST для SMT формулы}
\KwOut{Список символьных переменных}
\SetKwFunction{getleafs}{\textbf{GetLeafs}}
\SetKwFunction{issymvar}{\textbf{IsSymVar}}
\SetKwFunction{isconstant}{\textbf{IsConstant}}
\SetKw{continue}{\textbf{continue}}
% \Indm\nonl\printlcs{$V$}\\
% \KwResult{Write here the result
\SetKwProg{Fn}{Function}{:}{}
\Fn{\getleafs{$V$}}{
$Found \gets \emptyset$\;
  \For{$child \in V$} {
    \If{$\issymvar ( child ) $} {
        $Found \gets Found \cup \{ child \}$\;
    } \ElseIf{$\isconstant ( child ) $} {
        $\continue$\;
    }
    \Else {
      $Found \gets Found \cup \getleafs{child}$\;
    }
  }
  \Return{$Found$}\;
}
  \caption{Метод на основе символьного выполнения}
\end{algorithm}

\bigskip
Поскольку соответствие символьных переменных смещениям в файле известно~--- задача решена.

Однако существует еще одна проблема~--- предикат пути содержит условие на весь путь до данной точки, в то время как для решаемой задачи интерес представляет только его часть, отвечающая за последний переход.


Для решения этой проблемы вместо того, чтобы использовать сам предикат пути можно отслеживать события, заключающиеся в добавление в него новых условий и работать уже непосредственно с ними (добавление происходит в момент когда встречается условный переход). В случае \texttt{Angr} подобное решение достаточно легко реализуемо.

Данное решение обладает следующими преимуществами:
  \begin{itemize}
    \item Простой и понятный алгоритм
    \item Высокая точность работы (возможно достижение побитовой точности)
  \end{itemize}

При этом наличествуют следующие недостатки:
\begin{itemize}
  \item Низкая производительность (Построение формул на каждую инструкцию)
  \item Ни один из рассмотренных инструментов инструментов не позволяет реализовать метод, работающий на несинтетических примерах без ощутимых доработок самого инструмента.
\end{itemize}

Относительно пункта про производительность можно сделать несколько замечаний.
Во-первых, существует оптимизация, доступная например в \texttt{Triton}. Для того, чтобы сократить количество генерируемых уравнений можно использовать слайсинг по помеченным данным.
Во-вторых, с учетом замедления вносимого построением формул на каждую инструкцию, может быть целесообразнее непосредственно решать предикат пути и генерировать соответствующие входные данные.

\subsubsection{Решение на основе Angr}

Наиболее быстро вышеописанный метод можно реализовать на основе \texttt{Angr}. Несмотря на то, что само по себе полученное решение не применимо для крупных программ, полученный прототип хорошо иллюстрирует работу метода и его практическую применимость.

Полный программный код предложенного решения можно найти в приложении \ref{angrimpl}, ниже приводится пример его работы на простом примере.

\begin{lstlisting}[environoment=C_LANG, caption=jumper.c, label={lst:jumper}, captionpos=b]
int main(int argc, char** argv)
{
    char buff[SIZE];
    FILE *file1, *file2;
    file1 = fopen("input1", "r");
    file2 = fopen("input2", "r");
    fseek(file1, 10, SEEK_SET);
    if (!fread(buff, sizeof(char), 7, file1)) {
        return error_handler();
    }
    if (!fread(buff, sizeof(char), 2, file2)) {
        return error_handler();
    }
    if (buff[0] == 'a') {
        if (buff[3] == 'b') {
            loc1();
        } else if (buff[5] < buff[6]) {
            loc2();
        } else if (buff[2] >= buff[1]) {
            loc3();
        }
        loc4();
    }
    loc5();
    puts(buff);
}
\end{lstlisting}


Поскольку \texttt{Angr} использует онлайн поиск и поддерживает символьные файлы в качестве входного аргумента используется только имена файлов и адрес, путь к которому следует найти.

\begin{lstlisting}[caption=Интерфейс инструмента основанного на angr, captionpos=b]]
usage: taint_influence.py [-h] [-s] [-S FILE_SIZE] [-f FILES [FILES ...]]
                  binary func [args [args ...]]

Get tainted bytes for branches

positional arguments:
  binary                binary to analyse
  func                  function or adress to search
  args                  argv for program to analyse

optional arguments:
  -h, --help            show this help message and exit
  -s, --symbolic_argv   symbolize argv if set
  -S FILE_SIZE, --file-size FILE_SIZE
                        Size of symbolic files
  -f FILES [FILES ...], --files FILES [FILES ...]
                        list of files to symbolize
\end{lstlisting}

Ниже приводится пример работы инструмента, запущенного следующей строкой \texttt{taint\_influence.py jumper loc3 file -f input1 input2 -S 20}

\begin{lstlisting}[caption=Пример работы инструмента,captionpos=b]
=====Trace=========
------------------------------
Basic block addr: 0x401300
Instruction addr: 0x40130a
Formula: <Bool ((input1_40_160[63:56] - input2_41_160[151:144])[7:7] ^ ((input1_40_160[63:63] ^ input2_41_160[151:151]) & (input1_40_160[63:63] ^ (input1_40_160[63:56] - input2_41_160[151:144])[7:7]))) == 0>
Tainted bytes: {'input2': {1}, 'input1': {12}}


------------------------------
Basic block addr: 0x4012e8
Instruction addr: 0x4012f2
Formula: <Bool ((input1_40_160[39:32] - input1_40_160[31:24])[7:7] ^ ((input1_40_160[39:39] ^ input1_40_160[31:31]) & (input1_40_160[39:39] ^ (input1_40_160[39:32] - input1_40_160[31:24])[7:7]))) == 0>
Tainted bytes: {'input1': {16, 15}}


------------------------------
Basic block addr: 0x4012d4
Instruction addr: 0x4012da
Formula: <Bool input1_40_160[55:48] != 98>
Tainted bytes: {'input1': {13}}


------------------------------
Basic block addr: 0x4012cc
Instruction addr: 0x4012d2
Formula: <Bool input2_41_160[159:152] == 97>
Tainted bytes: {'input2': {0}}


===files====
<BV160 input1_40_160>
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9d\x00\x00\x00\x00\x00\x00'
<BV160 input2_41_160>
b'a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
\end{lstlisting}

Как можно видеть, инструмент корректно выводит байты влияющие на выполнение условного перехода. Кроме того \texttt{Angr} позволяет сгенерировать конкретные файлы на которых программа достигает интересующей инструкции.

% предикат пути представляется в виде конъюнкции предикатов
% поскольку одной из основных задач соответсвтующих инструментов является его конструирование

% каждому байту входного файла ставится в соответствие символьная переменная.
% для каждого предиката пути выполняется следующий алгоритм


% поскольку переменные взаимнооднозначно соответствуют адресам -- задача решена.

% \subsection{решение на основе angr}


\section{Использование анализа помеченных данных}
\label{taintmethod}

Метод на основе анализа помеченных данных во многом похож на метод с динамическим символьным выполнением. Так, первое что необходимо сделать -- корректно реализовать помечивание источников входных данных. Абстракций вроде символьного файла в случае анализа помеченных данных нет, поэтому используется механизм перехвата системных вызовов.

Первым делом встает вопрос о гранулярности меток. Использования гранулярности меньше байта не целесообразно, поскольку заметно влияет на производительность, в то время как точность в любом случае теряется. Например рассмотрим инструкцию \texttt{pcmpeqb xmm2, xmm1}, после выполнения этой инструкции \texttt{xmm2} должен содержать метки, относящиеся к обоим регистрам. Учесть какие именно биты повлияли на результат можно только методами символьного выполнения.
Использование побайтовых меток является приемлемым решением, тем не менее может иметь смысл использовать информацию о структуре файла, если она заранее известна для разметки. Так, при помощи утилиты \texttt{afl-analyze} можно узнать байты, отвечающие за некоторую контрольную сумму. Разумно пометить её одним тегом. В \cite{Angora} также предлагается использовать информацию о типах переменных, и проводить размечивание с учетом их размера. Данный подход требует предварительного статического анализа исходного кода или бинарного кода.

Кроме того, необходимо поддерживать неограниченное количество различных пометок для участка памяти. Это достаточно очевидное требование для поставленной задачи, но оно совсем не актуально для классической задачи анализа помеченных данных\footnote{Попадают ли данные из недоверенных источников в ``опасные'' функции}, поэтому оно не выполняется в большинстве рассмотренных в данной работе инструментов.

Распространение пометок может быть реализовано обычным образом, при этом следует считать помеченными данные адрес которых помечен, и не следует проводить распространение пометок по управлению, чтобы сохранить разумный баланс между ложнопомеченными и недопомеченными данными.

Само определение данных влияющих на условный переход сводится к тому, чтобы определить метки соответствующие регистру флагов непосредственно перед обработкой инструкции условного перехода.

Если резюмировать, алгоритм на основе анализа помеченных данных выглядит так:

\begin{itemize}
  \item Каждому байту входного файла ставится в соответсвие метка (тег).
  \item Для всех последующих инструкций в трассе выполнение выполняется алгоритм распространения пометок
  \item Для каждой инструкции условного извлекаются теги, которыми помечен регистр флагов. Байты, соответствующие этим тегам -- искомые.
\end{itemize}

К достоинствам описанного метода можно отнести его достаточно простую реализацию\footnote{В предположении, что уже имеется достаточно хороший инструмент для анализа помеченных данных} и высокую, по сравнению с символьным выполнением, скорость.

К недостаткам можно отнести худшую по сравнению с символьным выполнением точность. Например в \cite{Cavallaro07anti-taint-analysis:practical} приводится следующий пример.

\begin{lstlisting}[environoment=C_LANG,captionpos=b]
char y[256], x[256];
...
int n = read(network, y, sizeof(y));
for (int i=0; i < n; i++) {
    switch (y[i]) {
        case 0: x[i] = (char)13; break;
        case 1: x[i] = (char)14; break;
        ...
        case 255: x[i] = (char)12; break;
        default: break;
    }
}
\end{lstlisting}

Между $x$ и $y$ есть взаимно-однозначное соответствие, которое не отслеживается динамическим анализом помеченных данных. Данная проблема могла бы быть решена при помощи разрешение распространение зависимостей по управлению, но подобный подход приводит к огромному количеству ложнопомеченных данных, делая информацию о помеченности практически бесполезной.

Тем не менее, не смотря на вышеперечисленные недостатки, решение на основе анализ помеченных данных позволяет масштабироваться на настоящие приложения используемые в индустрии. Поэтому в рамках данной работы, было принято решение выбрать именно этот метод в качестве основы для дальнейших разработок.


% \section{Комбинированный подход}

% Оба предыдыщих подхода имеют недостатки. Построение символьных формул для всех инструкций может быть достаточно ресурсоемкой задачей. Время работы \em{Triton} может быть тому примером. В случае же, если используется онлайн символьное выполнение - проблема стоит еще острее, так \em{angr} вообще оказывается не очень применим на программах размером больше чем задания для CTF соревнований.
% \\
% С другой стороны, многие технологии анализа помеченных данных не поддерживают гранулярность на уровне отдельных байт, и возможность отследить от каких именно входных байт зависит некоторый адрес или регистр отсутствует. Даже если есть возможность отследить метки на каждый байт, существуют примеры когда этого недостаточно. так в \cite{Cavallaro07anti-taint-analysis:practical} приводится следующий пример, где 
% \\

