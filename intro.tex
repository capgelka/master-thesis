\chapter{Введение}


В последние годны наблюдается заметный рост количества уязвимостей в программном обеспечении. Так, согласно статистике \cite{CVEstats}, в $2016$ году было обнаружено $6447$ уязвимостей, в $2017$ --  $14714$, a в $2018$ -- $16555$. Это связано как с объемом и сложностью, разрабатываемого программного обеспечения, так и с развитием техник тестирования безопасности.

\begin{figure}[h]
    \center{
        \includegraphics[scale=0.5]{img/cve_stats.png}
    }
    \caption{Cтатистика опубликованных уязвимостей за последние 20 лет}
    \label{fig:image}
\end{figure}

Одним из популярных подходов к автоматизации поиска уязвимостей является фаззинг-тестирование. Это
техника тестирования программного обеспечения, заключающая в передаче приложению на вход неправильных, неожиданных или случайных данных.

P

Фаззинг-тестирование является достаточно популярным подходом в тестировании на безопасность.


В последние годы наблюдается рост интереса к фаззинг-тестированию.



\chapter{Обзор}

% \chapter{Методы реализации динамического анализа}

\section{Динамический Анализ}

Динамический анализ - это анализ, заключающийся в непосредственном выполнении кода. Однако, просто запустить программу может быть недостаточно. Существует несколько способов получения дополнительной информации во время выполнения:

\begin{itemize}
\item {\em Исполнение кода в виртуальном окружении}. При данном подходе программа запускается внутри некоторого программного эмулятора. Например qemu \cite{QEMU}.
%\item $\sigma$ is a {\em symbolic store} that associates program variables with expressions over \mynote{[D] $\alpha_i$ also concrete?} concrete and symbolic values $\alpha_i$.

\item {\em Статическая инструментация}.
Статическая инструментация бывает двух видов.
    \begin{itemize}
        \item {\em Статическая инструментация исходного кода}. В случае, если имеется доступ к исходному коду, можно просто внести изменения в текстовые файлы с кодом. Добавление отладочной печати может быть примером статической инструментации исходного кода. Подобный вид инструментации также поддерживается непосредственно компилятором. Так GCC имеет опцию  \textit{-finstrument-functions}
        \item {\em Статическая инструментация бинарного кода (SBI)}. В случае отсутствия исходного кода, изменениям может быть подвержен сам исполняемый файл на диске. Тривиальным примером такой инструментации может быть например замена условных переходов на \textint{nop} инструкции. 
    \end{itemize}

\item {\em Динамическая инструментация}. Данный вид инструментации позволяет вносить изменения в программу непосредственно в процессе её выполнения. Этот метод будет рассмотрен далее подробнее, как наиболее популярный среди инструментов, использованных в данной работе.


\section{Динамическая бинарная инструментация}

Рассмотрим несколько популярных DBI инструментов.

\subsection{Valgrind}
...

\subsection{Pin}
...

\section{Анализ помеченных данных}

Динамический анализ помеченных данных (Dynamic Taint Analysis, DTA), также известный как динамический анализ потока данных (Dynamic Flow tracking, DFT)(DFT) - это техника анализа програм, позволяющая определить какие состояния программы зависят от входных данных.
% Существует также статический анализ потока данных

Примером классической задачи, решаемой при помощи анализа помеченных данных, может служить задача определения достигают ли данные из недоверенного источника "Опасных" функций. Многие уязвимости в программном обеспечении обусловлены недостаточным контролем над входными данным. Применение анализа потока данных позволяет детектировать подобные проблемы.

Динамический анализ помеченных данных делится на 3 фазы

    \begin{itemize}
        \item {\em Определение источников помеченных данных}. На данном этапе определяется каким данные должны быть помечены. Обычно метками снабжаются данные, получаемые из недоверенного
        источника. В зависимости от типа приложения, это могут быть данные полученные по сети, из файла, или потока стандартного ввода.
        \item {\em Распространение пометок (Taint propogation)}. Для отслеживания потока данных, 
        для каждой инструкции манипулирующей данными необходимо написать инструментирующий код для манипуляции метками. Так, например инструкция \textint{mov eax, ebx} перезаписывает метку для регистра eax меткой регистра \textint{ebx}. Это фаза является самой сложной, поскольку оставляет много открытых вопросов. К примеру
        \begin{itemize}
            \item Следует ли отслеживать помеченность побайтово или побитого? Если \textint{eax} помечен, то после команды \textint{or eax, 0x746567bc} контролируются уже не все биты. Однако, в большинстве случаев отслеживание каждого бита может быть слишком дорогой операцией.
            \item Следует ли помечать адрес памяти, на который указывает помеченная переменная?
            \item Если условный переход зависит от помеченных данных, следует ли считать что последующие инструкции тоже от них зависят?
            \item Как хранить информацию о помеченных адресах в памяти?
            \item Cледует ли различать пометки, полученные из разных источников?
        \end{itemize}
        \item {\em Применение политик безопасности}. Фаза, на которой используются результаты анализа. Происходящее на этом этапе зависит от изначальных целей анализа. Типичным примером может быть отслеживание попадания помеченных данных в аргументы некоторых заранее выделенных функций, или факта помеченности счетчика инструкций.
    \end{itemize}


% \section{методы реализации технологии анализа помеченных данных}
Рассмотрим несколько подходов к реализации анализа помеченных данных.

% \subsection{Символьное выполнение}

\subsection{Множество помеченных адресов}

\subsection{Хэш таблица с побайтовыми метками}

\section{Символьное выполнение}


\section{Обзор технологий динамического анализа}

\section{Triton}

\section{angr}

\section{manticore}

\section{taintgrind}

\section{libdft}

\section{moflow}



\chapter{Сравнение инструментов для динамического анализа}

\section{Библиотека для снятия и анализа трас}

\section{Результаты сравнение}

\section{Выводы}




\chapter{Методы определения входных данных влияющих на условные переходы}

% Для начала расмотрим самый простой способ

\section{Использование символьного выполнение}

% Символьное выполнение


\section{Использование меток помеченных данных}

\section{Комбинированный подход}

Оба предыдыщих подхода имеют недостатки. Построение символьных формул для всех инструкций может быть достаточно ресурсоемкой задачей. Время работы \em{Triton} может быть тому примером. В случае же, если используется онлайн символьное выполнение - проблема стоит еще острее, так \em{angr} вообще оказывается не очень применим на программах размером больше чем задания для CTF соревнований.
\\
С другой стороны, многие технологии анализа помеченных данных не поддерживают гранулярность на уровне отдельных байт, и возможность отследить от каких именно входных байт зависит некоторый адрес или регистр отсутствует. Даже если есть возможность отследить метки на каждый байт, существуют примеры когда этого недостаточно. так в \cite{Cavallaro07anti-taint-analysis:practical} приводится следующий пример, где между x и y есть взаимно-однозначное соответствие, которое не отслеживается динамическим анализом помеченных данных.
\\

\begin{lstlisting}[environoment=C_LANG]
char y[256], x[256];
...
int n = read(network, y, sizeof(y));
for (int i=0; i < n; i++) {
    switch (y[i]) {
        case 0: x[i] = (char)13; break;
        case 1: x[i] = (char)14; break;
        ...
        case 255: x[i] = (char)12; break;
        default: break;
    }
}
\end{lstlisting}

\chapter{Прототипы решающие задачу}

\section{Решение на основе Angr}

\section{Решение на основе Moflow}

\chapter{Заключение}
% \subsection 




 % Для решения этой проблемы может использоваться динамическое символьное выполнение, например Driller для фаззера afl \cite{DRILLER}. Для улучшения работы фаззера