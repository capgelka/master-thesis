\documentclass[10pt]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\usetheme[
  sectionpage=simple,
  numbering=fraction
]{metropolis}
\usepackage{appendixnumberbeamer}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\usepackage{pgfplots}
\usepgfplotslibrary{dateplot}

\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}

\usepackage{todonotes}
\usepackage{ifthen}%
\providecommand\enabletodos{true}%
\ifthenelse{ \equal{\enabletodos}{true} }{%
  \presetkeys{todonotes}{inline}{}%
}{%
  \presetkeys{todonotes}{disable}{}%
}%

\setbeamertemplate{caption}{\raggedright\insertcaption\par}

\AtBeginSection[]{}

\setbeamertemplate{section in toc}{%
  \alert{$\bullet$}~\inserttocsection}
\setbeamercolor{subsection in toc}{bg=white,fg=structure}
\setbeamertemplate{subsection in toc}{%
  \hspace{1.2em}{\alert{\rule[0.3ex]{3pt}{3pt}}~\inserttocsubsection\par}}

\usepackage{hyperref}
\hypersetup{unicode=true}

\usepackage{tikz}
\usepackage{forest}
\usetikzlibrary{arrows,positioning}
\tikzset{
    % Define standard arrow tip
    >=latex,
    % Define arrow style
    ptr/.style={->, thick},
}
\usepackage{drawstack}
\usepackage{adjustbox}
\protected\def\psverb#1{\def\innerpsverb##1#1{\texttt{##1}}\innerpsverb}
\usepackage{listings}

\usepackage{makecell}

\usepackage[noline, noend]{algorithm2e} % For algorithms
\SetAlFnt{\footnotesize}

\usepackage{float}

\usepackage{changepage}

\lstdefinestyle{C}{
  language=C,
  % numbers=left,
  stepnumber=1,
  % numbersep=10pt,
  % tabsize=4,
  showspaces=false,
  showstringspaces=false
}
\lstset{basicstyle=\tiny,style=C}


\metroset{block=transparent}
\definecolor{Blue}{HTML}{2375a8}
\setbeamercolor{frametitle}{bg=Blue}
\setbeamercolor{palette primary}{bg=Blue}


\definecolor{Blue2}{HTML}{9ccff0}
\setbeamercolor{block title}{bg=Blue2}

\title{Магистерская диссертация на тему}
\subtitle{Исследование и разработка методов динамического анализа для определения входных данных влияющих на выполнение условных переходов}
\author{Дьячков Л.А.\\[10mm]{\small Руководитель: к.ф-м.н, с.н.с. Курмангалеев Ш.Ф.}}
% \author{}
\institute{ИСП РАН}
\date{5 Апрeля 2019}
\titlegraphic{\hfill\includegraphics[height=0.5cm]{logo_isp_ru.png}}

\begin{document}

\maketitle

% {%
% \setbeamertemplate{frame footer}{
% Падарян В.А., Соловьев М.А., Кононов А.И. "Моделирование операционной семантики
% машинных инструкций." Труды Института системного программирования РАН, том 19,
% стр. 165186. 2010.
% }
\begin{frame}{Введение}
  \begin{block}{Фаззинг}
  \textbf{Фаззинг-тестирование} -- активно развивающийся метод для поиска ошибок в программном обеспечении %\cite{DBLP:journals/corr/abs-1808-09700}.
  \end{block}
  \pause
  \begin{block}{Проблема}
  Может быть затруднено нахождение входных данных, позволяющих ``пройти'' условный переход
  \end{block}
  \pause
  \begin{block}{Предлагаемое решение}
    Использовать методы динамического анализа для определения какие байты из входного файла влияют на конкретный условный переход
  \end{block}
\end{frame}

\begin{frame}{Постановка задачи}

  \begin{block}{Цель работы}
    \begin{itemize}
    \item Разработка метода динамического анализа, позволяющего определять байты входного файла, влияющего на выполнение инструкции условного перехода.
    \item Программная реализация метода, работающая на операционной системе Linux с архитектурой процессора x86-64
    \end{itemize}
  \end{block}
  \pause

  \begin{block}{Подзадачи}
    \begin{itemize}
      \item Изучение существующих технологий динамического символьного выполнение и динамического анализа потока данных.
      \item Сравнение технологий на тестовом наборе
      \item Обзор возможных подходов, реализация прототипов, разработка метода
      \item Программная реализация на основе выбранной технологии
    \end{itemize}
  \end{block}

    % \textbf{Задача} Для сравнения инструментов использовать существующию инфраструктуру Google OSS-fuzz \\
    % \textbf{Результаты}
    % \begin{itemize}
    %   \item Изучена инфраструктура google os fuzz.
    %   \item Получено представление о работе afl и libfuzz (в меньшей степени) c точки зрения пользователя
    %   \item На jenkins заведен job, запускающий afl фаззер при помощи oss fuzz
    %   \item Понимание как адаптировать имеющуюся инфраструктуру для оценки инструментов taint анализа не получено
    % \end{itemize}
\end{frame}
%}%

\begin{frame}{Динамическое символьное выполнение}
  \begin{block}{Определение}
    Метод динамического анализа, заключающийся в том в том, что во время выполнения программы некоторым конкретным значениям ставятся в соответствие символьные переменные. Затем, для каждой выполняемой инструкции, генерируются формулы для SMT решателя.
  \end{block}
  \begin{block}{online символьное выполнение}
    Модуль символьного выполнения используется для того, чтобы генерировать конкретные данные для посещения новых узлов cfg программы.
  \end{block}
  \begin{block}{Offline символьное выполнение}
    Модуль символьного выполнения используется для анализа конкретной трассы выполнения.\pause \checkmark
  \end{block}
\end{frame}


\begin{frame}{Динамический анализ помеченных данных}
  \begin{block}{Определение}
    Динамический анализ помеченных данных (Dynamic Taint Analysis), также известный как динамический анализ потока данных (Dynamic Flow tracking) -- это техника анализа програм, позволяющая определить какие состояния программы зависят от входных данных.
  \end{block}
  \begin{block}{Принцип работы}
    \begin{itemize}
        \item {\em Определение источников помеченных данных}. Обычно метками снабжаются данные, получаемые из недоверенного источника (файл, stdin, сеть).
        \item {\em Распространение пометок (Taint propogation)}. Для каждой инструкции необходимо принять решение как распротраняются пометки в зависимости от её операндов и факта их помеченности
        % \begin{itemize}
        %     \item Следует ли отслеживать помеченность побайтово или побитого? Если \textint{eax} помечен, то после команды \textint{or eax, 0x746567bc} контролируются уже не все биты. Однако, в большинстве случаев отслеживание каждого бита может быть слишком дорогой операцией.
        %     \item Следует ли помечать адрес памяти, на который указывает помеченная переменная?
        %     \item Если условный переход зависит от помеченных данных, следует ли считать что последующие инструкции тоже от них зависят?
        %     \item Как хранить информацию о помеченных адресах в памяти?
        %     \item Cледует ли различать пометки, полученные из разных источников?
        % \end{itemize}
        \item {\em Применение политик безопасности}. Например отслеживание попадания помеченных данных в аргументы ``опасных'' функций, или факта помеченности счетчика инструкций.
    \end{itemize}
  \end{block}
\end{frame}

% \begin{frame}{Проблема распространения пометок}
%     \begin{itemize}
%         \item Следует ли отслеживать помеченность побайтово или побитого? Если \textit{eax} помечен, то после команды \textit{or eax, 0x746567bc} контролируются уже не все биты. 
%         \item Следует ли помечать адрес памяти, на который указывает помеченная переменная?
%         \item Если условный переход зависит от помеченных данных, следует ли считать что последующие инструкции тоже от них зависят?
%         \item Как хранить информацию о помеченных адресах в памяти?
%         \item Cледует ли различать пометки, полученные из разных источников?
%     \end{itemize}
% \end{frame}

\begin{frame}{Исследованные технологии}
  \begin{block}{Динамическое символьное выполнение}
    \begin{itemize}
      \item Triton
      \item Angr
      \item Manticore
    \end{itemize}
  \end{block}
    \begin{block}{Динамический анализ помеченных данных}
    \begin{itemize}
      \item Triton 
      \item Taintgrind
      \item libdft64
      \item moflow (bap gentrace)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Triton}
    Фреймворк, поддерживающий архитектуры x86 и x86-64, содержит модули DSE (offline) и анализа помеченных данных, использует \emph{Intel Pin} для динамической бинарной инструментации.
    \begin{block}{Достоинства}
        \begin{itemize}
        \item Поддерживает offline режим динамического символьного выполнения (Нет необходимости предварительно снимать трасу, при помощи pin это делается ``на лету'')
        \item Поддерживает \textbf{"ONLY\_TAINTED"}, позволяющий генерировать smt формулы только для помеченных инструкций
        \end{itemize}
    \end{block}

      \begin{block}{Недостатки}
          \begin{itemize}
      \item Работает крайне медленно (примерно на два порядка медленее других инструментов на базе pin)
      \item Нет поддержки символьных файлов/пометки данных на основе системных вызовов
      \item Грубый модуль пометки данных, низкая гранулярность over-approximation
      \end{itemize}
    \end{block}

\end{frame}

% \begin{frame}{Triton | Достоинства}
%     \begin{itemize}
%         \item Поддерживает offline режим динамического символьного выполнения (Нет необходимости предварительно снимать трасу, при помощи pin это делается ``на лету'')
%         \item Поддерживает \textbf{"ONLY\_TAINTED"}, позволяющий генерировать smt формулы только для
%         \item Богатое и документированное api c множеством примеров.
%         \item Поддерживает интерфейс для использования средств динамической бинарной инструментации, отличных от pin
%     \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Triton | Недостатки}
%       \begin{itemize}
%       \item 
%       \item Генерирует громоздкие SMT формулы для SSE инструкций. Предикат пути для примера ниже не решается в течение месяца.
%       \begin{verbatim}
%         for (int i = 0; i < arg_length; i++) {
%             buff[i] = (++argv[1][i]);
%         }
%         if (!strncmp(buff, "/home/", 6))
%         \end{verbatim}
%       \item Нет поддержки символьных файлов/пометки данных на основе системных вызовов.
%       \item Cодержит ошибки в реализации обработчиков нескольких инструкций
%       \begin{itemize}
%               \item Ошибка распространения пометов для инструкции \textbf{pcmpeqb} https://github.com/JonathanSalwan/Triton/issues/730
%               \item Неверный предикат пути для инструкции \textbf{repe cmpsb}
%           \end{itemize}
%       \end{itemize}
% \end{frame}

\begin{frame}{Angr}
    Платфмормонезависимый фреймворк динамического символьного выполнения, использующий трансляцию инструкций в VEX с последующей эмуляцией.
    \begin{block}{Достоинства}
      \begin{itemize}
        \item Поддержка множества архитектур
        \item Хороший онлайн движок, отлично работающий поиск состояний на небольших примерах.
        \item Есть множество полезных примитивов (таких как символьные файлы) из коробки
      \end{itemize}
    \end{block}
        \begin{block}{Недостатки}
          \begin{itemize}
      \item Нет оффлайн режима (плагины, которые должны его поддерживать не работают)
      \item На настоящих (например binutils) программах онлайн поиск не может дойти до интересных состояний 
      \end{itemize}
    \end{block}
\end{frame}


\begin{frame}{Manticore}
    Аналог Angr, поддерживающий также смарт-контракты. использует эмуляцию инструкций.
    \begin{block}{Достоинства}
      \begin{itemize}
        \item Поддерживает offline режим % на самом деле нет
      \end{itemize}
    \end{block}
        \begin{block}{Недостатки}
          \begin{itemize}
      \item Медленно работает (около 50 секунд эмуляции для того, чтобы дойти до main в программе с glibc)
      \item Нет поддержки SSE инструкций
      \item Нет поддержки некоторых системных вызовов при эмуляции
      \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Taintgrind}
    Плагин для valgrind, реализующий динамической анализ потока данных.
    \begin{block}{Достоинства}
      \begin{itemize}
        \item Поддержка множества архитектур (все что поддерживает valgrind)
        \item Возможность помечать данные из конкретных файлов
        \item Возможность статической инструментации исходного кода для пометки данных
      \end{itemize}
    \end{block}
        \begin{block}{Недостатки}
          \begin{itemize}
      \item Низкий уровень гранулярности пометок
      \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{libdft64}
    Инструмент для динамического анализа помеченных данных, работающий на основе \emph{Intel Pin}. Реализация libdft (поддерживает только x86) из проекта vuzzer64 работающая с 64 разрядными исполняемыми файлами. 
    \begin{block}{Достоинства}
      \begin{itemize}
        \item Возможность помечать данные из конкретных файлов
        \item Гранулярность меток на уровне байта
    \end{block}
        \begin{block}{Недостатки}
          \begin{itemize}
      \item Игнорируется регистр флагов
      \item Поддерживаются не все инструкции
      \end{itemize}
    \end{block}
\end{frame}


\begin{frame}{moflow (gentrace)}
    Инструмент для динамического анализа помеченных данных, работающий на основе \emph{Intel Pin}.
    Часть фреймворка moflow, изначально являющийся частью bap.
    \begin{block}{Достоинства}
      \begin{itemize}
        \item Возможность помечать данные из конкретных файлов
        \item Гранулярность меток на уровне байта
    \end{block}
        \begin{block}{Недостатки}
          \begin{itemize}
      \item Отсутсвии учета семантики инструкций в механизме распространения пометок
      \item Использование специальной метки \emph{MIXED\_TAINT} для случая, когда адресс зависит от нескольких пометок.
      \item Механизм распространения пометок работает на уровне старших регистров
      \end{itemize}
    \end{block}
\end{frame}

% \begin{frame}{Angr | Advantages}
%     \begin{itemize}
%       \item Good documentation
%       \item Under active development, so as many tools on top of it
%       \item Has it's own loader for binaries
%       \item Supports symbolic files and sockets out of the box
%       \item Supports a lot of CPU architectures (all that support lifting to VEX)
%       \item Powerful and documented API with many features
%       \item Modular architecture
%   \end{itemize}
% \end{frame}

% \begin{frame}{Динамическое бинарная инструментация}
%   \begin{block}{Определение}
%     Метод динамического анализа, заключающийся в том в том, что во время выполнения программы некоторым конкретным значениям ставятся в соответствие символьные переменные. Затем, для каждой выполняемой инструкции, генерируются формулы для SMT решателя.
%   \end{block}
%   \begin{block}{online символьное выполнение}
%     Модуль символьного выполнения используется для того, чтобы генерировать конкретные данные для посещения новых узлов cfg программы.
%   \end{block}
%   \begin{block}{Offline символьное выполнение}
%     Модуль символьного выполнения используется для анализа конкретной трассы выполнения.\pause \checkmark
%   \end{block}
% \end{frame}


    % \textbf{Задача.} Для сравнения инструментов необходимо разработать вспомогательную библиотеку, решающую следующие задачи:
    % \begin{itemize}
    %   \item Сбор информации об условных переходах (адрес, опкод, был ли совершен переход, является ли инструкция помеченной)
    %   \item Подсчет различных метрик (длина трассы, количество уникальных прыжков, количество помеченных прыжков)
    %   \item Возможность интеграции в проекты на языках С и python
    % \end{itemize}


% \begin{frame}{Решаемые подзадачи | Разработка библиотеки для снятия и анализа трасс}
%     \textbf{Результаты:}
%     \begin{itemize}
%       \item Разработана и покрыта тестами библиотека \emph{insrumentation-lib} на языке программирование Rust, предоставляющая интерфейсы для сбора трассы и подсчета метрик, а также поддерживающая сериализацию и десериализацию трассы.
%       \item Реализовна сборка в виде динамической библиотеки, статической библиотеки и в виде библиотеки для языков python2 и python3 
%       \item По техническим (PinCRT) причинам оказалось невозможно использовать библиотеку как предполагалось в проектах, используюших pin3.
%     \end{itemize}
% \end{frame}

% \begin{frame}{Решаемые подзадачи | Изучение инструментов }
%     \textbf{Задача.} Изучить реализацию и методы работы существующих инструментов динамического анализа, интегрировать в них разработанную библиотеку
%     \begin{itemize}
%         \item triton
%         \item libdft
%         \item taintgrind
%         \item moflow
%     \end{itemize}
% \end{frame}

% \begin{frame}{Решаемые подзадачи | Изучение инструментов }
%     \textbf{Результаты.} Изучить реализацию и методы работы существующих инструментов динамического анализа, интегрировать в них разработанную библиотеку
%     \begin{itemize}
%         \item Для triton все реализовано в соответсвии с планом.
%         \item Для libdft часть работ была проделана А. Харченко, из-за PinCRT было принято решение реализовать снятие интересующей информации без помощи \emph{instrumentation-lib}. Использовать утилиту на python на основе \emph{instrumentation-lib} для парсинга.
%         \item Для taintgrind все реализовано в соответсвии с планом.
%         \item Для moflow работа проделана Шамилем. (Но т.к. moflow в итоге был выбран, его изучение было проведено позднее)
%     \end{itemize}
% \end{frame}

% \begin{frame}{Решаемые подзадачи | Сравнение инструментов }
%     \textbf{Задача.} Сравнить работу инструментов на тестовых примерах из набора LAVA.\\
%     \textbf{Результаты.} 
%     \begin{itemize}
%         \item Были разработаны скрипты для
%         \begin{itemize}
%           \item параллельного запуска инструмента на тестовых примерах.
%           \item генерирование таблицы с результатами метрик.
%         \end{itemize}
%         \item на сервере ibis были проведены запуски инструментов и снятиы интересующие результаты.
%     \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Решаемые подзадачи | Генерирование тестовых программ для оценки качества taint}
%     \textbf{Задача.} Разработать генератор C программ, состоящих из последовательности вложенных if выражений над элеменатими последовательности де Брёйна.\\
%     \textbf{Результаты: } Успешно генерируются программы вида:
%     \begin{lstlisting}
% int main(int argc, char** argv)
% {
%  ... // this is one-byte examle, 4-bytes generates as well 
%  if (( data[ 0 ] | 110 ) < 143) {
%   data[1] ^= 56;
%   counter++;
%   if (( data[ 1 ] ^ 192 ) != 50) {
%    data[2] ^= 175;
%    counter++;
%   }
%  }
%  printf("%d", counter);
% }
% \end{lstlisting}
% Все выражения внутри if оказываются истины, так как в противном случае условие заменяется на обратное в процессе генерации.
% \end{frame}

% \begin{frame}{Решаемые подзадачи | Доработки moflow}
%     \textbf{Задача.} Улучшить механизм распространение пометок в Moflow.\\
%     \textbf{Проблемы: }
%     \begin{itemize}
%         \item Нет поддержки нескольких тегов для области памяти/регистра.
%         Специальный тег \emph{MIXED\_TAINT} для случая нескольких тегов. \textbf{(Решено)}
%         \item Отсутсвие учета семантики инструкции при распространении пометок
%         \item Поддерживаются только старшие регистры. \textbf{(В работе, планируется закончить до конца следующей недели)}
%     \end{itemize}
% \end{frame}

\appendix

%\begin{frame}[standout] \vfill Thanks for attention \vfill \end{frame}
\end{document}
